use crate::models::*;
use serde::Serialize;

pub struct ExploitationPathAnalyzer;

impl ExploitationPathAnalyzer {
    pub fn analyze_exploitation_path(&self, cve: &CVE) -> ExploitationAnalysis {
        ExploitationAnalysis {
            attack_surface: self.map_attack_surface(cve),
            privilege_escalation_chain: self.build_privilege_chain(cve),
            impact_propagation: self.analyze_impact_propagation(cve),
            exploitation_complexity: self.calculate_complexity(cve),
            proof_of_concept_framework: self.generate_poc_template(cve),
        }
    }

    fn map_attack_surface(&self, cve: &CVE) -> AttackSurface {
        AttackSurface {
            entry_points: self.identify_entry_points(cve),
            trust_boundaries: self.identify_trust_boundaries(cve),
            data_flow_paths: self.trace_data_flows(cve),
        }
    }

    fn identify_entry_points(&self, cve: &CVE) -> Vec<EntryPoint> {
        let mut entry_points = Vec::new();
        
        match &cve.exploitability.attack_vector {
            AttackVector::Network => {
                entry_points.push(EntryPoint {
                    interface_type: InterfaceType::NetworkAPI,
                    protocol: Some("HTTP/HTTPS/TCP/IP".to_string()),
                    authentication_required: cve.exploitability.privileges_required != PrivilegesRequired::None,
                    description: "Remote network service endpoint accessible over internet/local network".to_string(),
                });
                
                // Add specific entry points based on vulnerability type
                if let Some(cvss) = &cve.cvss {
                    if cvss.vector_string.contains("AV:N") {
                        entry_points.push(EntryPoint {
                            interface_type: InterfaceType::WebApplication,
                            protocol: Some("HTTP/HTTPS".to_string()),
                            authentication_required: cvss.vector_string.contains("PR:L") || cvss.vector_string.contains("PR:H"),
                            description: "Web application interface vulnerable to remote exploitation".to_string(),
                        });
                    }
                    
                    if self.description_indicates_rpc_vuln(&cve.description) {
                        entry_points.push(EntryPoint {
                            interface_type: InterfaceType::RPC,
                            protocol: Some("DCERPC/SMB/MSRPC".to_string()),
                            authentication_required: false,
                            description: "Remote Procedure Call interface with known vulnerability".to_string(),
                        });
                    }
                }
            },
            AttackVector::Adjacent => {
                entry_points.push(EntryPoint {
                    interface_type: InterfaceType::NetworkAPI,
                    protocol: Some("Local Area Network Protocols".to_string()),
                    authentication_required: cve.exploitability.privileges_required != PrivilegesRequired::None,
                    description: "Adjacent network service endpoint requiring local network access".to_string(),
                });
                
                entry_points.push(EntryPoint {
                    interface_type: InterfaceType::Wireless,
                    protocol: Some("WiFi/Ethernet".to_string()),
                    authentication_required: true,
                    description: "Wireless network access point within local network segment".to_string(),
                });
            },
            AttackVector::Local => {
                entry_points.push(EntryPoint {
                    interface_type: InterfaceType::CommandLine,
                    protocol: None,
                    authentication_required: true,
                    description: "Local command execution interface requiring authenticated access".to_string(),
                });
                
                entry_points.push(EntryPoint {
                    interface_type: InterfaceType::FileIO,
                    protocol: None,
                    authentication_required: true,
                    description: "Local file system access interface for privilege escalation".to_string(),
                });
                
                entry_points.push(EntryPoint {
                    interface_type: InterfaceType::IPC,
                    protocol: Some("Named Pipes/Shared Memory".to_string()),
                    authentication_required: true,
                    description: "Inter-process communication mechanisms for local exploitation".to_string(),
                });
            },
            AttackVector::Physical => {
                entry_points.push(EntryPoint {
                    interface_type: InterfaceType::Hardware,
                    protocol: None,
                    authentication_required: true,
                    description: "Physical hardware interfaces requiring direct device access".to_string(),
                });
                
                entry_points.push(EntryPoint {
                    interface_type: InterfaceType::Bootloader,
                    protocol: None,
                    authentication_required: false,
                    description: "Device boot process and firmware interfaces".to_string(),
                });
            },
        }
        
        // Add generic entry points based on vulnerable configurations
        for config in &cve.vulnerable_configurations {
            if config.cpe.contains("a:") {
                // Application vulnerability
                entry_points.push(EntryPoint {
                    interface_type: InterfaceType::ApplicationAPI,
                    protocol: Some("Application-specific protocol".to_string()),
                    authentication_required: cve.exploitability.privileges_required != PrivilegesRequired::None,
                    description: format!("Application interface for {} (CPE: {})", 
                                       self.extract_product_name(&config.cpe), config.cpe),
                });
            }
        }
        
        entry_points
    }

    fn description_indicates_rpc_vuln(&self, description: &str) -> bool {
        let indicators = ["rpc", "dcerpc", "msrpc", "remote procedure call", "smb"];
        indicators.iter().any(|&indicator| 
            description.to_lowercase().contains(indicator)
        )
    }

    fn extract_product_name(&self, cpe: &str) -> String {
        let parts: Vec<&str> = cpe.split(':').collect();
        if parts.len() > 4 {
            parts[4].to_string()
        } else {
            "Unknown Product".to_string()
        }
    }

    fn identify_trust_boundaries(&self, cve: &CVE) -> Vec<TrustBoundary> {
        let mut boundaries = Vec::new();
        
        match &cve.exploitability.attack_vector {
            AttackVector::Network => {
                boundaries.push(TrustBoundary {
                    name: "Network Perimeter".to_string(),
                    description: "Boundary between untrusted external networks and internal trusted systems".to_string(),
                    protection_mechanism: "Next-generation Firewall, Intrusion Detection/Prevention Systems, Network Segmentation".to_string(),
                    bypass_technique: "Protocol smuggling, port knocking, direct IP access, DNS tunneling".to_string(),
                });
                
                boundaries.push(TrustBoundary {
                    name: "Application Layer".to_string(),
                    description: "Boundary between web application frontend and backend systems".to_string(),
                    protection_mechanism: "Web Application Firewall, Input Validation, Output Encoding".to_string(),
                    bypass_technique: "Input validation bypass, encoding manipulation, business logic flaws".to_string(),
                });
            },
            AttackVector::Adjacent => {
                boundaries.push(TrustBoundary {
                    name: "Local Network Segment".to_string(),
                    description: "Boundary between local network segment and core infrastructure".to_string(),
                    protection_mechanism: "Network Access Control, VLAN Segmentation, Endpoint Protection".to_string(),
                    bypass_technique: "ARP spoofing, VLAN hopping, network discovery techniques".to_string(),
                });
            },
            AttackVector::Local | AttackVector::Physical => {
                boundaries.push(TrustBoundary {
                    name: "User Privilege Boundary".to_string(),
                    description: "Boundary between user-level processes and system-level privileges".to_string(),
                    protection_mechanism: "User Account Control, Capability-based Security, Mandatory Access Controls".to_string(),
                    bypass_technique: "Token manipulation, privilege escalation exploits, DLL injection".to_string(),
                });
                
                boundaries.push(TrustBoundary {
                    name: "Process Isolation".to_string(),
                    description: "Boundary between individual processes and system resources".to_string(),
                    protection_mechanism: "Address Space Layout Randomization, Data Execution Prevention, Sandboxing".to_string(),
                    bypass_technique: "Memory corruption exploits, side-channel attacks, process hollowing".to_string(),
                });
            },
        }
        
        // Add vulnerability-specific boundaries
        if let Some(cvss) = &cve.cvss {
            if cvss.vector_string.contains("S:C") {
                boundaries.push(TrustBoundary {
                    name: "Component Scope Boundary".to_string(),
                    description: "Boundary between vulnerable component and other system components".to_string(),
                    protection_mechanism: "Component isolation, API gateways, service mesh".to_string(),
                    bypass_technique: "Cross-component data flow manipulation, shared resource exploitation".to_string(),
                });
            }
        }
        
        boundaries
    }

    fn trace_data_flows(&self, cve: &CVE) -> Vec<DataFlowPath> {
        let mut flows = Vec::new();
        
        // Analyze based on vulnerability type inferred from CVSS and description
        let vuln_type = self.infer_vulnerability_type(cve);
        
        match vuln_type {
            VulnerabilityType::InputProcessing => {
                flows.push(DataFlowPath {
                    source: "Untrusted External Input".to_string(),
                    sink: "Application Input Validation".to_string(),
                    transformation: "Raw user input without proper sanitization".to_string(),
                    vulnerability_point: "Insufficient input validation allowing malicious payloads".to_string(),
                });
                
                flows.push(DataFlowPath {
                    source: "Validated Input".to_string(),
                    sink: "Application Business Logic".to_string(),
                    transformation: "Processing of validated but potentially malicious data".to_string(),
                    vulnerability_point: "Business logic flaws in data interpretation".to_string(),
                });
            },
            VulnerabilityType::MemoryCorruption => {
                flows.push(DataFlowPath {
                    source: "User-Controlled Data".to_string(),
                    sink: "Memory Buffer".to_string(),
                    transformation: "Unsafe copy operation without bounds checking".to_string(),
                    vulnerability_point: "Buffer overflow leading to memory corruption".to_string(),
                });
                
                flows.push(DataFlowPath {
                    source: "Corrupted Memory".to_string(),
                    sink: "Instruction Pointer".to_string(),
                    transformation: "Overwriting critical memory addresses".to_string(),
                    vulnerability_point: "Control flow hijacking enabling code execution".to_string(),
                });
            },
            VulnerabilityType::Authentication => {
                flows.push(DataFlowPath {
                    source: "Authentication Credentials".to_string(),
                    sink: "Authentication Subsystem".to_string(),
                    transformation: "Credential verification process".to_string(),
                    vulnerability_point: "Weak credential validation or session management".to_string(),
                });
                
                flows.push(DataFlowPath {
                    source: "Authenticated Session".to_string(),
                    sink: "Authorization Engine".to_string(),
                    transformation: "Access control decision making".to_string(),
                    vulnerability_point: "Privilege escalation through authorization bypass".to_string(),
                });
            },
            VulnerabilityType::Serialization => {
                flows.push(DataFlowPath {
                    source: "Serialized Data Stream".to_string(),
                    sink: "Deserialization Engine".to_string(),
                    transformation: "Object reconstruction from serialized data".to_string(),
                    vulnerability_point: "Unsafe deserialization of untrusted objects".to_string(),
                });
                
                flows.push(DataFlowPath {
                    source: "Reconstructed Objects".to_string(),
                    sink: "Application Logic".to_string(),
                    transformation: "Object usage in application context".to_string(),
                    vulnerability_point: "Arbitrary code execution through gadget chains".to_string(),
                });
            },
            _ => {
                // Generic data flow analysis
                if let Some(cvss) = &cve.cvss {
                    if cvss.vector_string.contains("C:H") {
                        flows.push(DataFlowPath {
                            source: "Sensitive Internal Data".to_string(),
                            sink: "External Output Channel".to_string(),
                            transformation: "Data serialization without encryption/access control".to_string(),
                            vulnerability_point: "Unauthorized data exposure point".to_string(),
                        });
                    }
                    
                    if cvss.vector_string.contains("I:H") {
                        flows.push(DataFlowPath {
                            source: "Untrusted External Input".to_string(),
                            sink: "Application Processing Logic".to_string(),
                            transformation: "Input processing without proper validation".to_string(),
                            vulnerability_point: "Data injection point allowing arbitrary modifications".to_string(),
                        });
                    }
                    
                    if cvss.vector_string.contains("A:H") {
                        flows.push(DataFlowPath {
                            source: "Resource Consumption Request".to_string(),
                            sink: "System Resources".to_string(),
                            transformation: "Resource allocation without limits".to_string(),
                            vulnerability_point: "Resource exhaustion point causing denial of service".to_string(),
                        });
                    }
                }
            }
        }
        
        if flows.is_empty() {
            flows.push(DataFlowPath {
                source: "General Input Processing".to_string(),
                sink: "Application Logic".to_string(),
                transformation: "Standard data flow processing with potential security gaps".to_string(),
                vulnerability_point: "Generic vulnerability in processing chain based on CVSS characteristics".to_string(),
            });
        }
        
        flows
    }

    fn infer_vulnerability_type(&self, cve: &CVE) -> VulnerabilityType {
        if let Some(cvss) = &cve.cvss {
            let vector = &cvss.vector_string;
            let description = &cve.description.to_lowercase();
            
            // Memory corruption patterns
            if vector.contains("A:H") && (description.contains("buffer overflow") || 
                                          description.contains("memory corruption") ||
                                          description.contains("heap overflow")) {
                return VulnerabilityType::MemoryCorruption;
            }
            
            // Authentication/Authorization patterns
            if (vector.contains("PR:N") || vector.contains("PR:L")) && 
               (description.contains("authentication") || description.contains("authorization") ||
                description.contains("login") || description.contains("session")) {
                return VulnerabilityType::Authentication;
            }
            
            // Serialization patterns
            if vector.contains("I:H") && vector.contains("C:H") &&
               (description.contains("deserialization") || description.contains("serialize")) {
                return VulnerabilityType::Serialization;
            }
            
            // Input validation patterns
            if vector.contains("AV:N") && (vector.contains("C:L") || vector.contains("I:L")) {
                return VulnerabilityType::InputProcessing;
            }
        }
        
        VulnerabilityType::Generic
    }

    fn build_privilege_chain(&self, cve: &CVE) -> Vec<PrivilegeEscalationStep> {
        let mut steps = Vec::new();
        let mut step_number = 1;
        
        // Initial access step based on attack vector and privileges required
        let (initial_privilege, technique) = match (&cve.exploitability.attack_vector, &cve.exploitability.privileges_required) {
            (AttackVector::Network, PrivilegesRequired::None) => {
                ("Unauthenticated External Attacker".to_string(), 
                 "Remote exploitation of network-accessible vulnerability".to_string())
            },
            (AttackVector::Network, PrivilegesRequired::Low) => {
                ("Authenticated Low-Privilege User".to_string(),
                 "Authenticated exploitation of network service with low privileges".to_string())
            },
            (AttackVector::Network, PrivilegesRequired::High) => {
                ("Authenticated High-Privilege User".to_string(),
                 "Authenticated exploitation requiring high-privilege account".to_string())
            },
            (AttackVector::Local, _) => {
                ("Local Authenticated User".to_string(),
                 "Local exploitation requiring system access".to_string())
            },
            (AttackVector::Adjacent, _) => {
                ("Adjacent Network Attacker".to_string(),
                 "Exploitation from same network segment".to_string())
            },
            (AttackVector::Physical, _) => {
                ("Physically Present Attacker".to_string(),
                 "Physical access-based exploitation".to_string())
            },
        };
        
        steps.push(PrivilegeEscalationStep {
            step_number,
            current_privilege: "External Threat Actor".to_string(),
            gained_privilege: initial_privilege.clone(),
            technique,
            evidence: "Initial vulnerability exploitation successful".to_string(),
        });
        
        step_number += 1;
        
        // Additional escalation based on CVSS scope and impact
        if let Some(cvss) = &cve.cvss {
            // If scope is changed, escalation to other components is likely
            if cvss.vector_string.contains("S:C") {
                steps.push(PrivilegeEscalationStep {
                    step_number,
                    current_privilege: initial_privilege.clone(),
                    gained_privilege: "Multiple System Components".to_string(),
                    technique: "Cross-component exploitation leveraging changed scope".to_string(),
                    evidence: "Compromise extends beyond initially vulnerable component".to_string(),
                });
                step_number += 1;
            }
            
            // High integrity impact suggests privilege escalation potential
            if cvss.vector_string.contains("I:H") && cve.exploitability.privileges_required != PrivilegesRequired::None {
                steps.push(PrivilegeEscalationStep {
                    step_number,
                    current_privilege: initial_privilege,
                    gained_privilege: "System Administrator/Root".to_string(),
                    technique: "Privilege escalation through high-integrity exploitation".to_string(),
                    evidence: "Full system compromise achieved through privilege escalation".to_string(),
                });
            }
        }
        
        steps
    }

    fn analyze_impact_propagation(&self, cve: &CVE) -> Vec<ImpactPropagation> {
        let mut impacts = Vec::new();
        
        if let Some(cvss) = &cve.cvss {
            // Confidentiality impact analysis
            if cvss.vector_string.contains("C:H") {
                impacts.push(ImpactPropagation {
                    component: "Data Confidentiality".to_string(),
                    impact_type: ImpactType::InformationDisclosure,
                    propagation_method: "Unauthorized access to sensitive data stores and transmission channels".to_string(),
                    containment_boundary: "Encryption, Access Control Lists, Data Loss Prevention".to_string(),
                });
            } else if cvss.vector_string.contains("C:L") {
                impacts.push(ImpactPropagation {
                    component: "Limited Data Exposure".to_string(),
                    impact_type: ImpactType::InformationDisclosure,
                    propagation_method: "Partial disclosure of non-sensitive information".to_string(),
                    containment_boundary: "Data Classification, Access Logging".to_string(),
                });
            }
            
            // Integrity impact analysis
            if cvss.vector_string.contains("I:H") {
                impacts.push(ImpactPropagation {
                    component: "System Integrity".to_string(),
                    impact_type: ImpactType::CodeExecution,
                    propagation_method: "Arbitrary code execution leading to complete system modification".to_string(),
                    containment_boundary: "Code Signing, Application Whitelisting, Process Isolation".to_string(),
                });
            } else if cvss.vector_string.contains("I:L") {
                impacts.push(ImpactPropagation {
                    component: "Partial System Modification".to_string(),
                    impact_type: ImpactType::CodeExecution,
                    propagation_method: "Limited system modifications and data alterations".to_string(),
                    containment_boundary: "File Integrity Monitoring, Change Management".to_string(),
                });
            }
            
            // Availability impact analysis
            if cvss.vector_string.contains("A:H") {
                impacts.push(ImpactPropagation {
                    component: "Service Availability".to_string(),
                    impact_type: ImpactType::DenialOfService,
                    propagation_method: "Complete service disruption through resource exhaustion or crash".to_string(),
                    containment_boundary: "Load Balancing, Redundancy, Rate Limiting".to_string(),
                });
            } else if cvss.vector_string.contains("A:L") {
                impacts.push(ImpactPropagation {
                    component: "Degraded Service Performance".to_string(),
                    impact_type: ImpactType::DenialOfService,
                    propagation_method: "Reduced service performance or intermittent availability".to_string(),
                    containment_boundary: "Performance Monitoring, Auto-scaling".to_string(),
                });
            }
            
            // Scope impact analysis
            if cvss.vector_string.contains("S:C") {
                impacts.push(ImpactPropagation {
                    component: "Cross-Component Impact".to_string(),
                    impact_type: ImpactType::Propagation,
                    propagation_method: "Vulnerability effects extend beyond the initially compromised component".to_string(),
                    containment_boundary: "Microservices Architecture, API Gateways, Network Segmentation".to_string(),
                });
            }
        }
        
        if impacts.is_empty() {
            impacts.push(ImpactPropagation {
                component: "Affected System Component".to_string(),
                impact_type: ImpactType::CodeExecution,
                propagation_method: "Generic impact based on vulnerability class and exploitability characteristics".to_string(),
                containment_boundary: "Standard system protections and security controls".to_string(),
            });
        }
        
        impacts
    }

    fn calculate_complexity(&self, cve: &CVE) -> ExploitationComplexity {
        let mut score: f32 = 0.0;
        let mut complexity_factors = Vec::new();
        
        // Factors affecting complexity based on actual CVE data
        match cve.exploitability.complexity {
            ExploitComplexity::Low => {
                score += 1.0;
                complexity_factors.push(("Low Attack Complexity", 1.0));
            },
            ExploitComplexity::High => {
                score += 3.0;
                complexity_factors.push(("High Attack Complexity", 3.0));
            },
        }
        
        if cve.exploitability.user_interaction {
            score += 1.5; // Requires social engineering or user action
            complexity_factors.push(("User Interaction Required", 1.5));
        } else {
            complexity_factors.push(("No User Interaction Required", 0.0));
        }
        
        match &cve.exploitability.privileges_required {
            PrivilegesRequired::None => {
                complexity_factors.push(("No Privileges Required", 0.0));
            },
            PrivilegesRequired::Low => {
                score += 1.0;
                complexity_factors.push(("Low Privileges Required", 1.0));
            },
            PrivilegesRequired::High => {
                score += 2.0;
                complexity_factors.push(("High Privileges Required", 2.0));
            },
        }
        
        match &cve.exploitability.attack_vector {
            AttackVector::Network => {
                complexity_factors.push(("Network-based Attack", 0.0)); // Generally easiest
            },
            AttackVector::Adjacent => {
                score += 0.5; // Requires adjacent network access
                complexity_factors.push(("Adjacent Network Required", 0.5));
            },
            AttackVector::Local => {
                score += 1.0; // Requires local access
                complexity_factors.push(("Local Access Required", 1.0));
            },
            AttackVector::Physical => {
                score += 2.0; // Requires physical access
                complexity_factors.push(("Physical Access Required", 2.0));
            },
        }
        
        // Adjust based on CVSS score and vector characteristics
        if let Some(cvss) = &cve.cvss {
            if cvss.base_score >= 9.0 {
                score -= 0.5; // Critical vulnerabilities are often well-documented
                complexity_factors.push(("Well-Known Critical Vulnerability", -0.5));
            } else if cvss.base_score <= 3.0 {
                score += 1.0; // Low severity may indicate obscure conditions
                complexity_factors.push(("Obscure Conditions Required", 1.0));
            }
            
            // Specialized factors
            if cvss.vector_string.contains("UI:R") {
                score += 0.5;
                complexity_factors.push(("Special User Interaction Needed", 0.5));
            }
            
            if self.description_indicates_complex_exploit(&cve.description) {
                score += 1.0;
                complexity_factors.push(("Complex Exploitation Technique", 1.0));
            }
        }
        
        // Configuration complexity
        if !cve.vulnerable_configurations.is_empty() {
            let config_complexity = (cve.vulnerable_configurations.len() as f32 * 0.1).min(1.0);
            score += config_complexity;
            complexity_factors.push(("Multiple Vulnerable Configurations", config_complexity));
        }
        
        ExploitationComplexity {
            overall_score: score.max(0.0),
            difficulty_level: match score {
                0.0..=1.0 => DifficultyRating::Beginner,
                1.1..=2.5 => DifficultyRating::Intermediate,
                2.6..=4.0 => DifficultyRating::Advanced,
                _ => DifficultyRating::Expert,
            },
            required_skills: self.determine_required_skills(score, cve),
            time_estimate: self.estimate_time_to_exploit(score),
            complexity_breakdown: complexity_factors,
        }
    }

    fn description_indicates_complex_exploit(&self, description: &str) -> bool {
        let indicators = ["race condition", "timing attack", "side channel", "cryptographic", "complex protocol"];
        indicators.iter().any(|&indicator| 
            description.to_lowercase().contains(indicator)
        )
    }

    fn determine_required_skills(&self, score: f32, cve: &CVE) -> Vec<SkillRequirement> {
        let mut skills = vec![
            SkillRequirement {
                skill: "Vulnerability Research".to_string(),
                proficiency_required: ProficiencyLevel::Basic,
            }
        ];
        
        // Add skills based on vulnerability characteristics
        if let Some(cvss) = &cve.cvss {
            if cvss.vector_string.contains("AV:N") {
                skills.push(SkillRequirement {
                    skill: "Network Protocol Analysis".to_string(),
                    proficiency_required: ProficiencyLevel::Intermediate,
                });
            }
            
            if cvss.vector_string.contains("I:H") || self.description_indicates_memory_corruption(&cve.description) {
                skills.push(SkillRequirement {
                    skill: "Binary Exploitation".to_string(),
                    proficiency_required: if score > 2.0 { ProficiencyLevel::Advanced } else { ProficiencyLevel::Intermediate },
                });
            }
            
            if self.description_indicates_web_vuln(&cve.description) {
                skills.push(SkillRequirement {
                    skill: "Web Application Security".to_string(),
                    proficiency_required: ProficiencyLevel::Intermediate,
                });
            }
        }
        
        if score > 1.0 {
            skills.push(SkillRequirement {
                skill: "Exploit Development".to_string(),
                proficiency_required: ProficiencyLevel::Intermediate,
            });
        }
        
        if score > 2.0 {
            skills.push(SkillRequirement {
                skill: "Reverse Engineering".to_string(),
                proficiency_required: ProficiencyLevel::Intermediate,
            });
        }
        
        if score > 3.0 {
            skills.push(SkillRequirement {
                skill: "Kernel/System Internals".to_string(),
                proficiency_required: ProficiencyLevel::Advanced,
            });
        }
        
        skills
    }

    fn description_indicates_memory_corruption(&self, description: &str) -> bool {
        let indicators = ["buffer overflow", "memory corruption", "use after free", "double free"];
        indicators.iter().any(|&indicator| 
            description.to_lowercase().contains(indicator)
        )
    }

    fn description_indicates_web_vuln(&self, description: &str) -> bool {
        let indicators = ["web application", "http", "html", "javascript", "browser", "web server"];
        indicators.iter().any(|&indicator| 
            description.to_lowercase().contains(indicator)
        )
    }

    fn estimate_time_to_exploit(&self, score: f32) -> TimeEstimate {
        match score {
            0.0..=1.0 => TimeEstimate {
                min_hours: 1,
                max_hours: 4,
                typical_hours: 2,
                confidence_level: "High".to_string(),
            },
            1.1..=2.0 => TimeEstimate {
                min_hours: 4,
                max_hours: 16,
                typical_hours: 8,
                confidence_level: "Medium".to_string(),
            },
            2.1..=3.0 => TimeEstimate {
                min_hours: 16,
                max_hours: 64,
                typical_hours: 32,
                confidence_level: "Medium".to_string(),
            },
            _ => TimeEstimate {
                min_hours: 64,
                max_hours: 256,
                typical_hours: 128,
                confidence_level: "Low".to_string(),
            },
        }
    }

    fn generate_poc_template(&self, cve: &CVE) -> PoCTemplate {
        let (language, framework) = match &cve.exploitability.attack_vector {
            AttackVector::Network => {
                if self.description_indicates_web_vuln(&cve.description) {
                    ("Python/JavaScript".to_string(), "Requests/Selenium".to_string())
                } else {
                    ("Python/C++".to_string(), "Scapy/Socket Programming".to_string())
                }
            },
            AttackVector::Local => ("C/C++/Python".to_string(), "Native APIs/Shell".to_string()),
            AttackVector::Physical => ("Hardware/C".to_string(), "Embedded Tools/Firmware".to_string()),
            _ => ("Python/Generic".to_string(), "Custom Framework".to_string()),
        };
        
        PoCTemplate {
            language,
            framework,
            template_code: self.create_template_code(cve),
            exploitation_steps: cve.exploitability.exploitation_steps.clone(),
            safety_notes: vec![
                "⚠️ Run only in authorized isolated lab environment with proper containment".to_string(),
                "⚠️ Ensure written authorization and legal compliance before testing any system".to_string(),
                "⚠️ Monitor system stability and implement immediate rollback procedures".to_string(),
                "⚠️ Document all testing activities for audit purposes".to_string(),
            ],
            target_environment: self.suggest_target_environment(cve),
        }
    }

    fn suggest_target_environment(&self, cve: &CVE) -> String {
        match &cve.exploitability.attack_vector {
            AttackVector::Network => {
                if self.description_indicates_web_vuln(&cve.description) {
                    "Web application test environment with isolated network segment".to_string()
                } else {
                    "Network testbed with packet capture and analysis capabilities".to_string()
                }
            },
            AttackVector::Local => "Isolated virtual machine or container with debugging tools".to_string(),
            AttackVector::Physical => "Dedicated hardware test platform with proper safety measures".to_string(),
            AttackVector::Adjacent => "Controlled local network environment with monitoring".to_string(),
        }
    }

    fn create_template_code(&self, cve: &CVE) -> String {
        match &cve.exploitability.attack_vector {
            AttackVector::Network => {
                if self.description_indicates_web_vuln(&cve.description) {
                    r#"#!/usr/bin/env python3
# Web Application Exploitation Template
import requests
import sys
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class WebExploitFramework:
    def __init__(self, target_url, verify_ssl=True):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()
        self.session.verify = verify_ssl
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
    
    def detect_vulnerability(self):
        """Detect presence of vulnerability"""
        try:
            # TODO: Customize detection logic based on specific CVE
            response = self.session.get(f"{self.target_url}/", headers=self.headers, timeout=10)
            
            # Example detection for common web vulnerabilities
            if response.status_code == 200:
                print(f"[+] Target {self.target_url} is accessible")
                return True
            else:
                print(f"[-] Target responded with status {response.status_code}")
                return False
                
        except Exception as e:
            print(f"[-] Error connecting to target: {e}")
            return False
    
    def exploit_vulnerability(self):
        """Exploit the vulnerability"""
        try:
            # TODO: Implement specific exploitation logic
            print("[*] Attempting exploitation...")
            
            # Example payload - customize for specific vulnerability
            payload = {
                "vulnerable_parameter": "EXPLOIT_PAYLOAD_HERE"
            }
            
            response = self.session.post(
                f"{self.target_url}/vulnerable_endpoint", 
                data=payload, 
                headers=self.headers,
                timeout=15
            )
            
                        if response.status_code in [200, 201]:
                print("[+] Exploitation successful!")
                return True
            else:
                print(f"[-] Exploitation failed with status {response.status_code}")
                return False
                
        except Exception as e:
            print(f"[-] Error during exploitation: {e}")
            return False

def main():
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <target_url>")
        print("Example: {sys.argv[0]} http:// vulnerable-app.example.com")
        sys.exit(1)
    
    target_url = sys.argv[1]
    
    print(f"[*] Testing CVE exploitation against {target_url}")
    
    exploit = WebExploitFramework(target_url)
    
    if exploit.detect_vulnerability():
        print("[+] Vulnerability detected")
        if exploit.exploit_vulnerability():
            print("[+] Exploitation completed successfully")
        else:
            print("[-] Exploitation failed")
    else:
        print("[-] Target not vulnerable or inaccessible")

if __name__ == "__main__":
    main()
"#.to_string()
                } else {
                    r#"#!/usr/bin/env python3
# Network Protocol Exploitation Template
import socket
import struct
import sys

class NetworkExploitFramework:
    def __init__(self, target_host, target_port):
        self.target_host = target_host
        self.target_port = target_port
    
    def create_payload(self):
        """Create exploitation payload - customize for specific vulnerability"""
        # TODO: Implement based on specific CVE characteristics
        # Example buffer overflow payload:
        # buffer = b"A" * offset
        # buffer += struct.pack("<I", ret_address)  # Return address overwrite
        # buffer += b"\x90" * 16  # NOP sled
        # buffer += shellcode  # Actual exploit code
        
        payload = b""
        payload += b"A" * 100  # Placeholder - replace with actual exploit
        payload += b"B" * 4    # Return address placeholder
        
        return payload
    
    def send_exploit(self):
        """Send exploit payload to target"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            
            print(f"[*] Connecting to {self.target_host}:{self.target_port}")
            sock.connect((self.target_host, self.target_port))
            
            payload = self.create_payload()
            print(f"[*] Sending payload ({len(payload)} bytes)")
            sock.send(payload)
            
            # Try to receive response
            try:
                response = sock.recv(1024)
                print(f"[+] Received response: {response[:50]}...")
            except socket.timeout:
                print("[*] No response received (may indicate success)")
            
            sock.close()
            return True
            
        except ConnectionRefusedError:
            print(f"[-] Connection refused to {self.target_host}:{self.target_port}")
            return False
        except Exception as e:
            print(f"[-] Error during exploitation: {e}")
            return False

def main():
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <target_host> <target_port>")
        print(f"Example: {sys.argv[0]} 192.168.1.100 80")
        sys.exit(1)
    
    target_host = sys.argv[1]
    target_port = int(sys.argv[2])
    
    print(f"[*] Testing network-based CVE exploitation against {target_host}:{target_port}")
    
    exploit = NetworkExploitFramework(target_host, target_port)
    success = exploit.send_exploit()
    
    if success:
        print("[+] Exploitation completed (check target for compromise)")
    else:
        print("[-] Exploitation failed")

if __name__ == "__main__":
    main()
"#.to_string()
                }
            },
            AttackVector::Local => {
                r#"#!/usr/bin/env python3
# Local Privilege Escalation Exploitation Template
import os
import sys
import subprocess
class LocalExploitFramework:
    def __init__(self):
        self.current_user = os.getenv('USER', 'unknown')
        self.platform = sys.platform
    
    def check_vulnerability(self):
        """Check if system is vulnerable"""
        print(f"[*] Checking vulnerability as user: {self.current_user}")
        
        # TODO: Implement specific vulnerability detection
        # Examples:
        # - Check vulnerable file permissions
        # - Check running service versions
        # - Check kernel version for known exploits
        
        try:
            # Example check - customize for specific CVE
            result = subprocess.run(['uname', '-a'], capture_output=True, text=True)
            print(f"[+] System info: {result.stdout.strip()}")
            return True
        except Exception as e:
            print(f"[-] Error during vulnerability check: {e}")
            return False
    
    def exploit_vulnerability(self):
        """Exploit the local vulnerability"""
        print("[*] Attempting local privilege escalation...")
        
        # TODO: Implement actual exploitation logic
        # Examples:
        # - Exploit SUID binaries
        # - Exploit kernel vulnerabilities
        # - Exploit misconfigured services
        
        try:
            # Example placeholder - customize for specific CVE
            print("[*] Running exploitation technique...")
            
            # WARNING: This is a placeholder - actual exploit code would go here
            print("[!] WARNING: This is a demonstration template only")
            print("[!] Actual exploit code must be implemented based on CVE details")
            
            return True
        except Exception as e:
            print(f"[-] Error during exploitation: {e}")
            return False

def main():
    print("[*] Local CVE Exploitation Framework")
    print("[!] ONLY USE IN AUTHORIZED TESTING ENVIRONMENTS")
    
    exploit = LocalExploitFramework()
    
    if exploit.check_vulnerability():
        print("[+] System appears vulnerable")
        if exploit.exploit_vulnerability():
            print("[+] Exploitation successful")
            # Check if privileges escalated
            current_uid = os.getuid()
            print(f"[+] Current UID: {current_uid}")
        else:
            print("[-] Exploitation failed")
    else:
        print("[-] System not vulnerable or check failed")

if __name__ == "__main__":
    main()
"#.to_string()
            },
            _ => {
                r#"#!/usr/bin/env python3
# Generic Exploitation Framework
import sys
import os

class GenericExploitFramework:
    def __init__(self, target_info=None):
        self.target_info = target_info or "unspecified"
        self.environment = os.name
    
    def check_vulnerability(self):
        """Generic vulnerability check"""
        print(f"[*] Checking vulnerability for: {self.target_info}")
        print(f"[*] Running on platform: {self.environment}")
        
        # TODO: Implement specific vulnerability detection logic
        # This should be customized based on CVE characteristics
        
        print("[*] Performing generic vulnerability assessment...")
        return True
    
    def exploit_vulnerability(self):
        """Generic exploitation attempt"""
        print("[*] Attempting exploitation...")
        
        # TODO: Implement actual exploitation logic
        # This should be customized based on CVE attack vector
        
        print("[!] WARNING: Generic template - customize for specific CVE")
        return True

def main():
    target_info = sys.argv[1] if len(sys.argv) > 1 else "default_target"
    
    print("[*] Generic CVE Exploitation Framework")
    print("[!] CUSTOMIZE THIS TEMPLATE FOR SPECIFIC VULNERABILITY")
    
    exploit = GenericExploitFramework(target_info)
    
    if exploit.check_vulnerability():
        print("[+] System appears vulnerable")
        if exploit.exploit_vulnerability():
            print("[+] Exploitation successful")
        else:
            print("[-] Exploitation failed")
    else:
        print("[-] System not vulnerable")

if __name__ == "__main__":
    main()
"#.to_string()
            }
        }
    }
}

#[derive(Debug, Clone, Serialize)]
pub struct ExploitationAnalysis {
    pub attack_surface: AttackSurface,
    pub privilege_escalation_chain: Vec<PrivilegeEscalationStep>,
    pub impact_propagation: Vec<ImpactPropagation>,
    pub exploitation_complexity: ExploitationComplexity,
    pub proof_of_concept_framework: PoCTemplate,
}

#[derive(Debug, Clone, Serialize)]
pub struct AttackSurface {
    pub entry_points: Vec<EntryPoint>,
    pub trust_boundaries: Vec<TrustBoundary>,
    pub data_flow_paths: Vec<DataFlowPath>,
}

#[derive(Debug, Clone, Serialize)]
pub struct EntryPoint {
    pub interface_type: InterfaceType,
    pub protocol: Option<String>,
    pub authentication_required: bool,
    pub description: String,
}

#[derive(Debug, Clone, Serialize)]
pub enum InterfaceType {
    NetworkAPI,
    WebApplication,
    RPC,
    CommandLine,
    FileIO,
    IPC,
    Wireless,
    Hardware,
    Bootloader,
    ApplicationAPI,
}

#[derive(Debug, Clone, Serialize)]
pub struct TrustBoundary {
    pub name: String,
    pub description: String,
    pub protection_mechanism: String,
    pub bypass_technique: String,
}

#[derive(Debug, Clone, Serialize)]
pub struct DataFlowPath {
    pub source: String,
    pub sink: String,
    pub transformation: String,
    pub vulnerability_point: String,
}

#[derive(Debug, Clone, Serialize)]
enum VulnerabilityType {
    InputProcessing,
    MemoryCorruption,
    Authentication,
    Serialization,
    Generic,
}

#[derive(Debug, Clone, Serialize)]
pub struct PrivilegeEscalationStep {
    pub step_number: usize,
    pub current_privilege: String,
    pub gained_privilege: String,
    pub technique: String,
    pub evidence: String,
}

#[derive(Debug, Clone, Serialize)]
pub struct ImpactPropagation {
    pub component: String,
    pub impact_type: ImpactType,
    pub propagation_method: String,
    pub containment_boundary: String,
}

#[derive(Debug, Clone, Serialize)]
pub enum ImpactType {
    CodeExecution,
    DataExfiltration,
    DenialOfService,
    PrivilegeEscalation,
    InformationDisclosure,
    Propagation,
}

#[derive(Debug, Clone, Serialize)]
pub struct ExploitationComplexity {
    pub overall_score: f32,
    pub difficulty_level: DifficultyRating,
    pub required_skills: Vec<SkillRequirement>,
    pub time_estimate: TimeEstimate,
    pub complexity_breakdown: Vec<(&'static str, f32)>,
}

#[derive(Debug, Clone, Serialize)]
pub enum DifficultyRating {
    Beginner,
    Intermediate,
    Advanced,
    Expert,
}

#[derive(Debug, Clone, Serialize)]
pub struct SkillRequirement {
    pub skill: String,
    pub proficiency_required: ProficiencyLevel,
}

#[derive(Debug, Clone, Serialize)]
pub enum ProficiencyLevel {
    Basic,
    Intermediate,
    Advanced,
    Expert,
}

#[derive(Debug, Clone, Serialize)]
pub struct TimeEstimate {
    pub min_hours: u32,
    pub max_hours: u32,
    pub typical_hours: u32,
    pub confidence_level: String,
}

#[derive(Debug, Clone, Serialize)]
pub struct PoCTemplate {
    pub language: String,
    pub framework: String,
    pub template_code: String,
    pub exploitation_steps: Vec<String>,
    pub safety_notes: Vec<String>,
    pub target_environment: String,
}



